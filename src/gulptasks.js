
var _         = require('lodash')
  , dox       = require('dox')
  , exec      = require('child_process').exec
  , fs        = require('fs')
  , gconnect  = require('gulp-connect')
  , jshint    = require('gulp-jshint')
  , gmocha    = require('gulp-mocha')
  , gtemplate = require('gulp-template')
  , gutil     = require('gulp-util')
  , marked   = require('marked')
  , mdconf    = require('mdconf')
  , mkdirp    = require('mkdirp')
  , path      = require('path')
  , thisPkg   = require('../package.json')

var baseDir = path.join(__dirname, '..')

var configMd = path.join(baseDir , 'config.md')
  , configMdContent = readFileContent(configMd)
  , rootDir  = path.join(baseDir , 'root')

var config = mdconf(configMdContent).config

function emptyTask (next) { next() }

/* Generate *ignore* files
 *
 * Use instead of *createTaskGenerateFile* cause *.npmignore* and *.gitignore* 
 * cannot be stored as raw files.
 *
 * Files will not be overwritten.
 *
 * @api private
 * @param {Object} gulp
 * @param {String} taskName
 * @param {Array} rows file content
 */

function createTaskGenerateIgnoreFile (gulp, taskName, rows) {
  var fileName = '.' + taskName

  if (fs.existsSync(fileName))
    gulp.task(taskName, emptyTask)
  else
    gulp.task(taskName, function (next) {
      var footer = ['# end of', thisPkg.name, 'stuff'].join(' ') .concat("\n")
        , header = ['# generated by', thisPkg.name, thisPkg.version].join(' ')

      var content = [header, rows.join("\n"), footer].join("\n")

      writeFileContent(fileName, content)

      next()
    })
}

/* Render files from template
 *
 * @api private
 * @param {Object} gulp
 * @param {String} taskName
 * @param {String} fileName
 * @param {Object} pkg
 * @param {Object} config
 * @param {Boolean} touch do not overwrite file
 */

function createTaskGenerateFile (gulp, fileName, pkg, config, touch) {
  // Create an empty task if fileName already exists
  if (touch && fs.existsSync(fileName))
    return gulp.task(fileName, emptyTask)

  // TODO if pkg is private do not add version (first) badge
  // TODO ## Template section in config.md
  var badges = [
        '[![NPM version](https://badge.fury.io/js/<%= pkg.name %>.png)](http://badge.fury.io/js/<%= pkg.name %>)'
      , '[![Build Status](https://travis-ci.org/<%= pkg.author.name %>/<%= pkg.name %>.png?branch=master)](https://travis-ci.org/<%= pkg.author.name %>/<%= pkg.name %>.png?branch=master)'
      , '[![Dependency Status](https://gemnasium.com/<%= pkg.author.name %>/<%= pkg.name %>.png)](https://gemnasium.com/<%= pkg.author.name %>/<%= pkg.name %>)'
      , '[![Stories in Ready](https://badge.waffle.io/<%= pkg.author.name %>/<%= pkg.name %>.png?label=ready&title=Ready)](https://waffle.io/<%= pkg.author.name %>/<%= pkg.name %>)'
      ]
    , taskName = fileName
    , templateData = {
        bootstrap: {
          cdn: '//netdna.bootstrapcdn.com/bootstrap/3.1.1/'
        }
      , dox: {}
      , docs: {}
      , meta: {
          keywords: ['Casati', 'Gianluca', 'fibo']
        }
      , my : {}
      , pkg: pkg
      , readme: {}
      }

  if (pkg.keywords)
    templateData.meta.keywords = pkg.keywords

  templateData.my.filename = path.basename(fileName)

  templateData.badges = _.template(badges.join(' '), templateData)

  if (fs.existsSync('./README.md'))
    templateData.readme.md = readFileContent('./README.md')
  else
    templateData.readme.md = _.template(readFileContent(path.join(rootDir, 'README.md')), templateData)

  templateData.readme.html = marked(templateData.readme.md)

  templateData.docs.header = _.template(readFileContent(path.join(rootDir, 'docs', '_header.html')), templateData)
  templateData.docs.footer = _.template(readFileContent(path.join(rootDir, 'docs', '_footer.html')), templateData)

  if (fs.existsSync(config.tasks.dox.outputfile))
    templateData.dox = JSON.parse(readFileContent(config.tasks.dox.outputfile))

  gulp.task(taskName, function () {
     var dest = path.dirname(fileName)
       , src  = path.join(rootDir, fileName)

     return gulp.src(src)
                .pipe(gtemplate(templateData))
                .pipe(gulp.dest(dest))
  })
}

/* Get content from file
 *
 * @api private
 * @param {String} path
 * @return {String} fileContent
 */

function readFileContent (path) {
  var fileContent

  try {
    fileContent = fs.readFileSync(path, {encoding: 'utf8'})
  }
  catch (err) { throw err }

  return fileContent
}

/* Write content to file
 *
 * @api private
 * @param {String} filePath
 * @param {String} fileContent
 */

function writeFileContent (filePath, fileContent) {
    try {
      mkdirp(path.dirname(filePath))
      fs.writeFileSync(filePath, fileContent, {encoding: 'utf8'})
    }
    catch (err) { throw err }
}

/* Parse source comments with dox
 *
 * @api private
 * @param {String} source /path/to/input/file.js
 * @return {Object} doxObj
 */

function doxParse (source) {
  gutil.log('doxParse ' + source)

  var doxObj
    , doxOptions = {debug: false, raw: true}
    , fileContent = readFileContent(source)

  doxObj = dox.parseComments(fileContent, doxOptions)

  doxObj.forEach(function (elem, i) {
    doxObj[i].description.body    = marked(elem.description.body)
    doxObj[i].description.full    = marked(elem.description.full)
    doxObj[i].description.summary = marked(elem.description.summary)

    if (elem.tags)
      elem.tags.forEach(function(tag, j) {
        if (doxObj[i].tags[j].description)
          doxObj[i].tags[j].description = marked(doxObj[i].tags[j].description)
      })

  })

  return doxObj
}

/* Executes given command
 *
 * ```
 * execCommand('npm install')()
 * ```
 *
 * @api private
 * @param {String} command
 * @return {Function} execChild
 */

function execCommand (command) {
  return function execChild (next) {
    var child = exec(command)

    gutil.log(command)

    child.stderr.pipe(process.stderr)
    child.stdout.pipe(process.stdout)

    next()
  }
}

/* Create gulp tasks
 *
 * Used in *gulpfile.js*, see [installation section](./#installation) to know
 * how to create a *gulpfile.js*.
 *
 * @param {Object} gulp from `require(gulp)`
 * @param {Object} pkg data from package.json
 */

function gulptasks (gulp, pkg) {
  gulp.task('default', config.tasks.default)

  gulp.task('docsreload', function () {
     gulp.src(config.tasks.watch.docs.glob)
         .pipe(gconnect.reload())
  })

  gulp.task('docsserver', config.tasks.docsserver.deps, function () {
    var conf = config.tasks.docsserver

    gconnect.server({
      root: conf.root,
      livereload: true
    })
  })

  gulp.task('dox', config.tasks.dox.deps, function (next) {
    var conf    = config.tasks.dox
      , doxData = {}
      , srcDir  = 'src'

    var files = fs.readdirSync(srcDir)

    files.forEach(function (fileName) {
      // ignore index.js
      if (fileName === 'index.js')
        return

      // All input files should have extension .js
      var source = path.join(srcDir, fileName)
      var item = path.basename(fileName, '.js')

      var doxObj = doxParse(source)
      doxData[item] = doxObj
    })

    writeFileContent(conf.outputfile, JSON.stringify(doxData, null, 4))

    next()
  })

  config.tasks.touch.files.forEach(function (fileName) {
    createTaskGenerateFile(gulp, fileName, pkg, config, true)
  })

  gulp.task('touch', config.tasks.touch.deps.concat(config.tasks.touch.files), emptyTask)

  config.tasks.generatedocs.files.forEach(function (fileName) {
    createTaskGenerateFile(gulp, fileName, pkg, config, false)
  })

  gulp.task('generatedocs', config.tasks.generatedocs.deps.concat(config.tasks.generatedocs.files), emptyTask)

  gulp.task('generateignorefiles', config.tasks.generateignorefiles.deps, emptyTask)

  createTaskGenerateIgnoreFile(gulp, 'gitignore', config.tasks.gitignore)

  gulp.task('githubpages', execCommand(config.tasks.githubpages))

  gulp.task('gitpull', execCommand(config.tasks.gitpull))

  gulp.task('gitpush', execCommand(config.tasks.gitpush))

  gulp.task('jshint', function () {
    return gulp.src(config.tasks.watch.src.glob)
               .pipe(jshint())
               .pipe(jshint.reporter('default'))
  })

  gulp.task('mocha', function () {
    var conf = config.tasks.mocha

    return gulp.src(config.tasks.watch.test.glob)
               .pipe(gmocha({reporter: conf.reporter}))
  })

  createTaskGenerateIgnoreFile(gulp, 'npmignore', config.tasks.npmignore)

  gulp.task('npminstall', execCommand(config.tasks.npminstall))

  gulp.task('packagejson', function (next) {
    var conf = config.tasks.packagejson

    pkg.author = config.author

    pkg.homepage = config.author.url + '/' + pkg.name

    pkg.license = [ conf.license ]

    pkg.scripts.test = conf.scripts.test

    writeFileContent('./package.json', JSON.stringify(pkg, null, 2))

    next()
  })

  var macroTasks = ['dev', 'deploy' ,'setup' , 'test']

  macroTasks.forEach(function(taskName) {
    var deps = config.tasks[taskName].deps || []

    gulp.task(taskName, deps, emptyTask)
  })

  gulp.task('watch', function () {
    var conf = config.tasks.watch

    function logFileChanged (event) {
      gutil.log('File ' + event.path + ' was ' + event.type + ', running tasks...')
    }

    gulp.watch(conf.docs.glob, conf.docs.tasks)
        .on('change', logFileChanged)

    gulp.watch(conf.readme.glob, conf.readme.tasks)
        .on('change', logFileChanged)

    gulp.watch(conf.src.glob, conf.src.tasks)
        .on('change', logFileChanged)

    gulp.watch(conf.test.glob, conf.test.tasks)
        .on('change', logFileChanged)
  })
}

module.exports = gulptasks

