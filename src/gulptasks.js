
var _         = require('lodash')
  , dox       = require('dox')
  , exec      = require('child_process').exec
  , fs        = require('fs')
  , gconnect  = require('gulp-connect')
  , jshint    = require('gulp-jshint')
  , gmocha    = require('gulp-mocha')
  , gtemplate = require('gulp-template')
  , gutil     = require('gulp-util')
  , mdconf    = require('mdconf')
  , mkdirp    = require('mkdirp')
  , path      = require('path')
  , thisPkg   = require('../package.json')

var baseDir = path.join(__dirname, '..')

var configMd = path.join(baseDir , 'config.md')
  , rootDir  = path.join(baseDir , 'root')

var config = mdconfFromFile(configMd).config

var readmeContentPath = 'readmeContent.md'

/*
 *
 * @api private
 * @param {Object} gulp
 * @param {String} filename
 */

function createTaskCopyFile (gulp, fileName) {
  gulp.task(fileName, function () {
     var dest = path.dirname(fileName)
       , src  = path.join(rootDir, fileName)

     gutil.log('copy ' + src + ' -> ' + dest)

     return gulp.src(src)
                .pipe(gulp.dest(dest))
  })
}

/*
 * Generates a file, use instead of *createTaskCopyFile* if file has a special
 * meaning, like *.npmignore* and *.gitignore* and it cannot be stored as a raw file.
 * Files will not be overwritten.
 *
 * @api private
 * @param {Object} gulp
 * @param {String} taskName
 * @param {Array} rows file content
 */

function createTaskGenerateIgnoreFile (gulp, taskName, rows) {
  var fileName = '.' + taskName

  if (fs.existsSync(fileName))
    gulp.task(taskName, [])
  else
    gulp.task(taskName, function () {
      var footer = ['# end of', thisPkg.name, 'stuff'].join(' ') .concat("\n")
        , header = ['# generated by', thisPkg.name, thisPkg.version].join(' ')

      var content = [header, rows.join("\n"), footer].join("\n")

      fs.writeFileSync(fileName, content, {encoding: 'utf8'})
    })
}

/*
 *
 * @api private
 * @param {Object} gulp
 * @param {String} fileName
 * @param {Object} templateData
 */

function createTaskRenderTemplate (gulp, fileName, templateData) {
  gulp.task(fileName, function () {
     var dest = path.dirname(fileName)
       , src  = path.join(rootDir, fileName)

     gutil.log('render ' + src + ' -> ' + dest)

     return gulp.src(src)
                .pipe(gtemplate(templateData))
                .pipe(gulp.dest(dest))
  })
}

/*
 * Copies a file **only** if it does not exists.
 *
 * @api private
 * @param {Object} gulp
 * @param {String} fileName
 */

function createTaskTouchFile (gulp, fileName) {
  // Create an empty task if fileName already exists
  if (fs.existsSync(fileName))
    gulp.task(fileName, [])
  else
    createTaskCopyFile(gulp, fileName)
}

/*
 * Get content from file
 *
 * @param {String} path
 * @return {String} fileContent
 */

function readFileContent (path) {
  try {
    fileContent = fs.readFileSync(path, {encoding: 'utf8'})
  }
  catch (err) { throw err }
}

/*
 *
 * @api private
 * @param {String} source /path/to/input/file.js
 * @return {Object} doxObj
 */

function doxParse (source) {
  gutil.log('doxParse ' + source)

  var fileContent = readFileContent(source)

  var doxOptions = {debug: false, raw: true}

  var doxObj = dox.parseComments(fileContent, doxOptions)

  return doxObj
}

/*
 * Executes given command as a child
 *
 * ```
 * execCommand('npm install')()
 * ```
 *
 * @api private
 * @param {String} command
 * @return {Function} execChild
 */

function execCommand(command) {
  return function execChild() {
    var child = exec(command)

    gutil.log(command)

    child.stderr.pipe(process.stderr)
    child.stdout.pipe(process.stdout)
  }
}

/*
 * Read configuration parameters from markdown file
 *
 * @api private
 * @param fileName {String} /path/to/file.md
 */

function mdconfFromFile (fileName) {
  var fileContent

  try {
    fileContent = fs.readFileSync(fileName, {encoding: 'utf8'})
  }
  catch (err) { throw err }

  return mdconf(fileContent)
}

/*
 * Create gulp tasks
 *
 * @param {Object} gulp
 * @param {Object} pkg object from package.json
 */

function gulptasks (gulp, pkg) {
  gulp.task('config', function () {
    console.log(JSON.stringify(config, null, 4))
  })

  config.tasks.copyfiles.forEach(function (fileName) {
    createTaskCopyFile(gulp, fileName)
  })

  gulp.task('copyfiles', config.tasks.copyfiles)

  gulp.task('docs', config.tasks.docs)

  gulp.task('docsreload', function (next) {
     gulp.src('./docs/*.html')
         .pipe(gconnect.reload())
  })

  gulp.task('docsserver', function (next) {
    var conf = config.tasks.docsserver

    gconnect.server({
      root: conf.root,
      livereload: true
    })
  })

  gulp.task('dox', function () {
    var conf    = config.tasks.dox
      , doxData = {}
      , srcDir  = 'src'

    var files = fs.readdirSync(srcDir)

    files.forEach(function (fileName) {
      // ignore index.js
      if (fileName === 'index.js')
        return

      // All input files should have extension .js
      var source = path.join(srcDir, fileName)
      var item = path.basename(fileName, '.js')

      var doxObj = doxParse(source)
      doxData[item] = doxObj
    })

    try {
      mkdirp(path.dirname(conf.outputfile))
      fs.writeFileSync(conf.outputfile, JSON.stringify(doxData, null, 4), {encoding: 'utf8'})
    }
    catch (err) { throw err }
  })

  gulp.task('default', config.tasks.default)

  gulp.task('generatefiles', config.tasks.generatefiles)

  createTaskGenerateIgnoreFile(gulp, 'gitignore', config.tasks.gitignore)

  gulp.task('gitpush', execCommand(config.tasks.gitpush))

  gulp.task('jshint', function () {
    gulp.src('src/*js')
        .pipe(jshint())
        .pipe(jshint.reporter('default'))
  })

  gulp.task('mkdirs', function () {
    config.tasks.mkdirs.forEach(function (dir) { mkdirp(dir) })
  })

  createTaskGenerateIgnoreFile(gulp, 'npmignore', config.tasks.npmignore)

  gulp.task('npminstall', execCommand(config.tasks.npminstall))

  gulp.task('packagejson', function () {
    var conf = config.tasks.packagejson

    pkg.devDependencies = conf.devdependecies

    pkg.homepage = 'http://www.g14n.info/' + pkg.name

    pkg.license = [ conf.license ]

    pkg.scripts.test = conf.scripts.test

    fs.writeFileSync('./package.json', JSON.stringify(pkg, null, 2), {encoding: 'utf8'})
  })

  var renderTemplatesConf = config.tasks.rendertemplates
    , renderTemplatesDeps = ['copyfiles', 'touchfiles', 'dox']

  renderTemplatesConf.forEach(function (element) {
    renderTemplatesDeps.push(element)
  })

  renderTemplatesConf.forEach(function (fileName) {
    var templateData = {
          pkg: pkg
        , readmeContent: '**TODO:** edit file ' + readmeContentPath
        , readmeContentPath: readmeContentPath
        }
      , docs = {}

    docs.header = _.template(readFileContent(path.join(rootDir, 'docs', '_header.html')), templateData)
    docs.footer = _.template(readFileContent(path.join(rootDir, 'docs', '_footer.html')), templateData)
    gutil.log(docs.header)

    templateData.docs = docs

    if (fs.existsSync(config.tasks.dox.outputfile))
      templateData.dox = require(config.tasks.dox.outputfile)
    else
      templateData.dox = {}


    fs.readFile(readmeContentPath, {encoding: 'utf8'}, function (err, data) {
      if (!err)
        templateData.readmeContent = data
    })

    createTaskRenderTemplate(gulp, fileName, templateData)
  })

  gulp.task('rendertemplates', renderTemplatesDeps)

  gulp.task('scaffold', config.tasks.scaffold)

  gulp.task('test', function () {
    var conf = config.tasks.test

    gulp.src('test/*js')
        .pipe(gmocha({reporter: conf.reporter}))
  })

  config.tasks.touchfiles.forEach(function (fileName) {
    createTaskTouchFile(gulp, fileName)
  })

  gulp.task('touchfiles', config.tasks.touchfiles)

  gulp.task('watch', function () {
    gulp.watch('./docs/*.html', ['docsreload'])

    gulp.watch('src/**', [])
        .on('change', function (event) {
          gutil.log('File '+event.path+' was '+event.type+', running tasks...')
        })
  })
}

/*!
 * Export
 */

module.exports = gulptasks

